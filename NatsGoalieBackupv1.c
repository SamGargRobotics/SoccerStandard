#pragma config(Sensor, S2,     irFront,         sensorI2CCustom)
#pragma config(Sensor, S1,     irBack,        sensorI2CCustom)
#pragma config(Sensor, S3,     compass,        sensorEV3_GenericI2C)
#pragma config(Motor,  motorA,          frontleft,     tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorB,          frontright,    tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorC,          backright,      tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorD,          backleft,     tmotorEV3_Medium, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-irseeker-v2.h"
#include "PF_Motors.c"

int irFrontDir, irFrontStr;
int irBackDir, irBackStr;

tHTIRS2 irSeeker1;
tHTIRS2 irSeeker2;

int comp;
int defStr = 200;
unsigned long pgmStart;
unsigned long timerDuration = 2000; // Adjust the duration as needed
unsigned long timerStart = nPgmTime;

task TimerRestart() {
	while (true) {
		if (nPgmTime - timerStart >= timerDuration) {
			// Restart the timer when the duration is reached
			timerStart = nPgmTime;
		}
	}
}

int minus = SensorValue(S3);
int speed = 100;

bool compcorrection(){
	comp = SensorValue(S3) - minus;
	if(comp < 0){
		comp = 180 + comp;
	}
	if(comp < 5 || comp > 175){
		return true;
	}
	else if(comp > 90){
		motorIn.structure.A = -1*(comp-180);
		motorIn.structure.B= -(comp-180);
		motorIn.structure.C=(comp-180);
		motorIn.structure.D=(comp-180);
	}
	else{
		motorIn.structure.A=-comp;
		motorIn.structure.B=-comp;
		motorIn.structure.C=comp;
		motorIn.structure.D=comp;
	}
	return false;
}

void rightspot(){
	motorIn.structure.A=0;
	motorIn.structure.B=-speed;
	motorIn.structure.C=speed;
	motorIn.structure.D=0;
}

void leftspot(){
	motorIn.structure.A=0;
	motorIn.structure.B=speed;
	motorIn.structure.C=-speed;
	motorIn.structure.D=0;
}

void still(){
	motorIn.structure.A=0;
	motorIn.structure.B=0;
	motorIn.structure.C=0;
	motorIn.structure.D=0;
}
void front(){
	motorIn.structure.A=-speed;
	motorIn.structure.B=-speed;
	motorIn.structure.C=-speed;
	motorIn.structure.D=-speed;
}

void back(){
	motorIn.structure.A=speed;
	motorIn.structure.B=speed;
	motorIn.structure.C=speed;
	motorIn.structure.D=speed;
}

void left(){
	motorIn.structure.A=-speed;
	motorIn.structure.B=speed;
	motorIn.structure.C=-speed;
	motorIn.structure.D=speed;
}

void right(){
	motorIn.structure.A=speed;
	motorIn.structure.B=-speed;
	motorIn.structure.C=speed;
	motorIn.structure.D=-speed;
}

void leftfront(){
	motorIn.structure.A=0;
	motorIn.structure.B=speed;
	motorIn.structure.C=0;
	motorIn.structure.D=speed;
}

void rightfront(){
	motorIn.structure.A=speed;
	motorIn.structure.B=0;
	motorIn.structure.C=speed;
	motorIn.structure.D=0;
}

void leftback(){
	motorIn.structure.A=-speed;
	motorIn.structure.B=0;
	motorIn.structure.C=-speed;
	motorIn.structure.D=0;
}
void rightback(){
	motorIn.structure.A=speed;
	motorIn.structure.B=0;
	motorIn.structure.C=speed;
	motorIn.structure.D=0;
}


void frontcon() {
    if (irFrontStr >= defStr) {
        if (nPgmTime - pgmStart >= timerDuration) {
            pgmStart = nPgmTime;
            front();
            wait1Msec(1000); // Pause for 1000 milliseconds (1 second)
        } else if (nPgmTime - pgmStart >= timerDuration / 2) {
            back();
            wait1Msec(500); // Pause for 500 milliseconds (0.5 seconds)
        }
    } else {
        still();
    }
}

void rfcon() {
    if (irFrontStr >= defStr) {
        if (nPgmTime - pgmStart >= timerDuration) {
            pgmStart = nPgmTime;
            rightfront();
            wait1Msec(1000); // Pause for 1000 milliseconds (1 second)
        } else if (nPgmTime - pgmStart >= timerDuration / 2) {
            leftback();
            wait1Msec(500); // Pause for 500 milliseconds (0.5 seconds)
        }
    } else {
        still();
    }
}

void lfcon() {
    if (irFrontStr >= defStr) {
        if (nPgmTime - pgmStart >= timerDuration) {
            pgmStart = nPgmTime;
            leftfront();
            wait1Msec(1000); // Pause for 1000 milliseconds (1 second)
        } else if (nPgmTime - pgmStart >= timerDuration / 2) {
            rightback();
            wait1Msec(500); // Pause for 500 milliseconds (0.5 seconds)
        }
    } else {
        still();
    }
}



task main {
	initPFMotors();
	startMotorTask();
	pgmStart = nPgmTime;
	initSensor(&irSeeker1, irBack);
	initSensor(&irSeeker2, irFront);
	startTask(TimerRestart);
	while(true){
		readSensor(&irSeeker1);
		readSensor(&irSeeker2);
		int ir1 = SensorValue[S1];
		writeDebugStream("irvalue %4d/n", ir1);
		irFrontDir = irSeeker1.acDirection;
		irFrontStr = irSeeker1.enhStrength;
		irBackDir = irSeeker2.acDirection;
		irBackStr = irSeeker2.enhStrength;
		if(SensorValue(S2)<10){
			still();
		}
		if(irFrontStr >= irBackStr) {
			switch(irFrontDir) {
			case 1:
				leftspot();
				break;
			case 2:
				leftspot();
				break;

			case 3:
				leftspot();
				break;

			case 4:
				rfcon();
				break;

			case 5:
				frontcon();
				break;

			case 6:
				lfcon();
				break;

			case 7:
				rightspot();
				break;

			case 8:
				rightspot();
				break;

			case 9:
				rightspot();
				break;
			default:
				still();
				break;
			}
		}
		else
		{
			switch(irBackDir) {
			case 1:
				rightspot();
				break;
			case 2:
				rightspot();
				break;
			case 3:
				rightspot();
				break;
			case 4:
				rightspot();
				break;
			case 5:
				still();
				break;
			case 6:
				still();
				break;
			case 7:
				leftspot();
				break;
			case 8:
				leftspot();
				break;
			case 9:
				leftspot();
				break;
			}
		}
	}
}

#pragma config(Sensor, S1,     IRfront,        sensorI2CCustom)
#pragma config(Sensor, S2,     IRback,         sensorI2CCustom)
#pragma config(Sensor, S3,     Compass,        sensorEV3_GenericI2C)
#pragma config(Motor,  motorA,          brPF,          tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorB,          blPF,          tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorC,          tlPF,          tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorD,          trPF,          tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-irseeker-v2.h" //IRsensor Library
#include "PF_Motors.h" // PF Motor Library
#include "PF_Motors.c" // PF Motor Library

#define COMP_MULTI 0.7 //Compass Multiplier (Sense of Direction in degrees)

//int frontStr; //Front IR sensor beacon strength detection variable
//int backStr; //Back IR sensor beacon strength detection variable
int current; //Compass value at the start of program
int target; //Target
int motorVal[4] = {0, 0, 0, 0};
float ballDir; //Direction of ball
//float pgmStart; //Timer Start
float compassValue; //Current compass value
float correction;
float max(float a, float b) {
	return a > b? a : b;
}

int motorSpeeds[18][4] = {
	{ 100, 100,-100,-100}, //Forward
	{		0,   0,   0,   0}, //Forward Right - More forward
	{-100, 100, 100,-100}, //Right
	{-100,   0, 100,   0}, //Back Right
	{-100,-100, 100, 100}, //Backward
	{		0,-100,		0, 100}, //Back Left
	{ 100,-100,-100, 100}, //Left
	{		0,   0,   0,   0}, //Forward Left - More forward
	{		0,	 0,   0,   0}, // Still
	{ 100, 100,-100,-100}, //Forward
	{		0, 100,   0,-100}, //Forward Right
	{-100, 100, 100,-100}, //Right
	{-100,   0, 100,   0}, //Back Right
	{-100,-100, 100, 100}, //Backward
	{		0,-100,		0, 100}, //Back Left
	{ 100,-100,-100, 100}, //Left
	{ 100,   0,-100,   0}, //Forward Left
	{   0,   0,   0,   0}, //Still
};

float calculateCorrection(int target, int current) {
	float correction = (current - target) * 2.0;

	if(correction > 180) {
		correction -= 360;
	} else if(correction < -180) {
		correction += 360;
	}

	if(correction > 100) {
		correction = 100;
	} else if(correction < -100) {
		correction = -100;
	}

	return correction * COMP_MULTI;
}

int calculateBallDir(int frontStr, int backStr, int frontDir, int backDir) {
	int ballDir;
	if(frontStr >= backStr){
		switch(frontDir) {
		case 1:
			ballDir = 4;
			break;
		case 2:
			ballDir = 5;
			break;
		case 3:
			ballDir = 6;
			break;
		case 4:
			ballDir = 7;
			break;
		case 5:
			ballDir = 0;
			break;
		case 6:
			ballDir = 1;
			break;
		case 7:
			ballDir = 2;
			break;
		case 8:
			ballDir = 3;
			break;
		case 9:
			ballDir = 4;
			break;
		default:
			ballDir = 4;
		}
		} else {
		switch(backDir) { // NOTE: Find out how to get AROUND the ball, not directly at it
		case 1:
			ballDir = 16;
			break;
		case 2:
			ballDir = 17;
			break;
		case 3:
			ballDir = 9;
			break;
		case 4:
			ballDir = 10;
			break;
		case 5:
			ballDir = 11;
			break;
		case 6:
			ballDir = 17;
			break;
		case 7:
			ballDir = 9;
			break;
		case 8:
			ballDir = 10;
			break;
		case 9:
			ballDir = 11;
			break;
		default:
			ballDir = 9;
		}
	}
	return ballDir;
}

void moving(int ballDir, float correction) {
	for(int i = 0; i < 4; i++) {
		motorVal[i] = motorSpeeds[ballDir][i];
		motorVal[i] -= correction;
	}

	float highestVal = max(abs(motorVal[0]), abs(motorVal[1]));
	highestVal = max(highestVal, abs(motorVal[2]));
	highestVal = max(highestVal, abs(motorVal[3]));
	if(highestVal > 100) {
		if(highestVal != 0) {
			for(int i = 0; i <= 3; i++) {
				motorVal[i] /= highestVal;
				motorVal[i] *= 100;
			}
		}
	}
	motorIn.structure.A = motorVal[0];
	motorIn.structure.B = motorVal[1];
	motorIn.structure.C = motorVal[2];
	motorIn.structure.D = motorVal[3];
}
task main()
{
	tHTIRS2 irSeeker1;
	tHTIRS2 irSeeker2;
	initSensor(&irSeeker1, IRfront);
	initSensor(&irSeeker2, IRback); //Initialising IR sensor's.
	initPFMotors();
	startMotorTask(); //Allows PF's to work
	current = SensorValue[S3];
	target = current; //Compass Correction values
	for(int i = 0; i < 4; i++) {
			motorIn.array[i] = 0;
	} //Array for movement

	while(true) {
		unsigned long pgmStart;
		pgmStart = nPgmTime; //Timer
		readSensor(&irSeeker1);
		readSensor(&irSeeker2); //Reading IR Sensors
		compassValue = SensorValue[S3];
		compassValue = current;
		correction = calculateCorrection(target, current); //Compass and Corrections
		ballDir = calculateBallDir(irSeeker1.enhStrength, irSeeker2.enhStrength, irSeeker1.acDirection, irSeeker2.acDirection);
		//Ball Direction
		moving(ballDir, correction); //Actually moving the robot 0_0
		displayTextLine(1, "D:%4d %4d %3d", irSeeker1.dcDirection, irSeeker1.acDirection, irSeeker1.enhDirection);
		displayTextLine(2, "D:%4d %4d %3d", irSeeker2.dcDirection, irSeeker2.acDirection, irSeeker2.enhDirection);
		displayTextLine(3, "D:%4d %4d %3d", compassValue);
		displayTextLine(4, "D:%4d %4d %3d", current); //Variable Values
	}
}

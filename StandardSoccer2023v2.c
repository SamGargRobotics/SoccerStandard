#pragma config(Sensor, S1,     IRfront,        sensorI2CCustom)
#pragma config(Sensor, S2,     IRback,         sensorI2CCustom)
#pragma config(Sensor, S3,     Compass,        sensorEV3_GenericI2C)
#pragma config(Motor,  motorA,          brPF,          tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorB,          blPF,          tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorC,          tlPF,          tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorD,          trPF,          tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-irseeker-v2.h" //IRsensor Library
#include "PF_Motors.h" // PF Motor Library
#include "PF_Motors.c" // PF Motor Library
#define COMP_MULTI 0.7 //Compass Multiplier (Sense of Direction in degrees)

int frontStr; //Front IR sensor beacon strength detection variable
int backStr; //Back IR sensor beacon strength detection variable
float current; //Current direction of compass
float ballDir; //Direction of ball
float correction; //Distance of degrees between your robot and beacon (facing)
float target; //Beacon Target
float pgmStart; //Timer Start

/* Basic Motor Movements */
//Still   			{    0,    0,    0,    0}
//Left    			{  100, -100, -100,  100}
//Right   			{ -100,  100,  100, -100}
//Forward 			{  100,  100, -100, -100}
//Back    			{ -100, -100,  100,  100}
//Back-Right		{ -100,    0,  100,    0}
//Forward-Left	{  100,    0, -100,    0}
//Forward-Right	{    0,  100,    0, -100}
//Back-Left			{    0, -100,    0,  100}

float calculateCorrection(int target, int current) { // This section works fine, Correction = angled distance between our robot and ball.
	float correction = (target - current) * 2.0;

	if(correction > 180) {
		correction -= 360;
	}
	else if(correction < -180) {
		correction += 360;
	}

	if(correction > 100) {
		correction = 100;
	}

	if(correction < -100) {
		correction = -100;
	}
	correction *= COMP_MULTI;

	return correction;
}

int calculateBallDir(int frontStr, int backStr, int frontDir, int backDir) {
	int ballDir;
	if(frontStr >= backStr){
		switch(frontDir) {
		case 1:
			ballDir = 4;
			break;
		case 2:
			ballDir = 5;
			break;
		case 3:
			ballDir = 6;
			break;
		case 4:
			ballDir = 7;
			break;
		case 5:
			ballDir = 0;
			break;
		case 6:
			ballDir = 1;
			break;
		case 7:
			ballDir = 2;
			break;
		case 8:
			ballDir = 3;
			break;
		case 9:
			ballDir = 4;
			break;
		default:
			ballDir = 4;
		}
		} else {
		switch(backDir) { // NOTE: Find out how to get AROUND the ball, not directly at it
		case 1:
			ballDir = 16;
			break;
		case 2:
			ballDir = 17;
			break;
		case 3:
			ballDir = 9;
			break;
		case 4:
			ballDir = 10;
			break;
		case 5:
			ballDir = 11;
			break;
		case 6:
			ballDir = 17;
			break;
		case 7:
			ballDir = 9;
			break;
		case 8:
			ballDir = 10;
			break;
		case 9:
			ballDir = 11;
			break;
		default:
			ballDir = 9;
		}
	}
	return ballDir;
}

task main()
{
	tHTIRS2 irSeeker1;
	tHTIRS2 irSeeker2; //Allowing IR sensor's to function
	initSensor(&irSeeker1, IRfront);
	initSensor(&irSeeker2, IRback); //Initialising sensor's.
	initPFMotors();
	startMotorTask();
	while(true) {
		unsigned long pgmStart;
		pgmStart = nPgmTime;
		readSensor(&irSeeker1);
		readSensor(&irSeeker2);
		current = SensorValue(Compass);
		ballDir = calculateBallDir(irSeeker1.enhStrength, irSeeker2.enhStrength, irSeeker1.acDirection, irSeeker2.acDirection);
		correction = calculateCorrection(target, current);
		displayTextLine(1, "D:%4d %4d %3d", irSeeker1.dcDirection, irSeeker1.acDirection, irSeeker1.enhDirection);
		displayTextLine(2, "D:%4d %4d %3d", irSeeker2.dcDirection, irSeeker2.acDirection, irSeeker2.enhDirection);
	}
	if (ballDir == 5) {
		while(nPgmTime - pgmStart < 500) {
			motorIn.structure.A = 0;
			motorIn.structure.B = 100;
			motorIn.structure.C = 0;
			motorIn.structure.D = 100;
		}
		motorIn.structure.A = 0;
		motorIn.structure.B = 0;
		motorIn.structure.C = 0;
		motorIn.structure.D = 0;
		while(true) {
			motorIn.structure.A = 100;
			motorIn.structure.B = 100;
			motorIn.structure.C = -100;
			motorIn.structure.D = -100;
		}
	}
}

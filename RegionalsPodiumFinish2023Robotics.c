#pragma config(Sensor, S1,     IRfront,        sensorI2CCustom)
#pragma config(Sensor, S2,     IRback,         sensorI2CCustom)
#pragma config(Sensor, S3,     Compass,        sensorEV3_GenericI2C)
#pragma config(Motor,  motorA,          brPF,          tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorB,          frPF,          tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorC,          flPF,          tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorD,          blPF,          tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-irseeker-v2.h" //IRsensor Library
#include "PF_Motors.h" // PF Motor Library
#include "PF_Motors.c" // PF Motor Library

#define DEG2RAD(angleDegrees) (angleDegrees * 3.141592 / 180.0)
#define RAD2DEG(angleRadians) (angleRadians * 180.0 / 3.141592)

#define COMP_MULTI 0.7 //Compass Multiplier (Sense of Direction in degrees)
#define SPEED 100 //Motor speed

int current; //Compass value at the start of program
int target; //Target
float motorVal[4] = {0, 0, 0, 0}; //Motor Functions

float ballDir; //Direction of ball
float pgmStart; //Timer Start
float compassValue; //Current compass value
float correction;
float frontStr; //Front IR sensor beacon strength detection variable
float backStr; //Back IR sensor beacon strength detection variable
float orbitDir;
float max(float a, float b) { //Defining 'Max' variable
	return a > b? a : b;
}

float strength1;
float strength2;

int orbitDirFar[18] = { //What you can do is have 2 arrays, one for very far and one for very close. And you can scale the angle based on the distance value of the ball. Only issue is Lego sensors are quite in accurate compared to our lightweight ones, so it may not work as well.
	0, //Front
	25, //
	63, //Front Right
	83, //
	121, //Right
	138, //Right
	175, //
	196, //Back Right
	213, //
	75, //Back
	88, //
	104, //Back Left
	125, //
	163, //Left
	179, //Left
	217, //
	238, //Front Left
	275 //
};

int orbitDirClose[18] = { //orbit far / by 1.2
	0, //Front
	20, //
	52, //Front Right
	69, //
	100, //Right
	115, //Right
	145, //
	163, //Back Right
	177, //
	62, //Back
	73, //
	86, //Back Left
	104, //
	135, //Left
	149, //Left
	180, //
	198, //Front Left
	229, //
};
float calculateCorrection(int target, int current) {
	float error = current - target;
	if (error > 90) {
		error -= 180;
		} else if (error < -90) {
		error += 180;
	}
	return error * COMP_MULTI;
}

int calculateBallDir(int frontStr, int backStr, int frontDir, int backDir) {
	int ballDir;
	if(frontStr >= backStr){
		switch(frontDir) {
		case 1:
			ballDir = 14;
			break;
		case 2:
			ballDir = 15;
			break;
		case 3:
			ballDir = 16;
			break;
		case 4:
			ballDir = 17;
			break;
		case 5:
			ballDir = 0;
			break;
		case 6:
			ballDir = 1;
			break;
		case 7:
			ballDir = 2;
			break;
		case 8:
			ballDir = 3;
			break;
		case 9:
			ballDir = 4;
			break;
		default:
			ballDir = 4;
		}
		} else {
		switch(backDir) { // NOTE: Find out how to get AROUND the ball, not directly at it
		case 1:
			ballDir = 5;
			break;
		case 2:
			ballDir = 6;
			break;
		case 3:
			ballDir = 7;
			break;
		case 4:
			ballDir = 8;
			break;
		case 5:
			ballDir = 9;
			break;
		case 6:
			ballDir = 10;
			break;
		case 7:
			ballDir = 11;
			break;
		case 8:
			ballDir = 12;
			break;
		case 9:
			ballDir = 13;
			break;
		default:
			ballDir = 9;
		}
	}
	return ballDir;
}

void moving(int Dir, float correction) {
	writeDebugStream("Speed %4d\n", correction);
	int angles[4] = {45, 135, 225, 315};
	for(int i = 0; i < 4; i++) {
		int moveDir = angles[i] + Dir;
		while(moveDir >= 360) {
			moveDir -= 360;
		}
		motorVal[i] = cosDegrees(angles[i] + Dir)*SPEED + correction*COMP_MULTI;
		//writeDebugStream("Speed %4d %4f\n", i, motorVal[i]);
	}
	float maxS = 1;
	for(int i = 0; i<4; i++) {
		motorIn.structure.A = motorVal[3];
		motorIn.structure.B = motorVal[0];
		motorIn.structure.C = motorVal[1];
		motorIn.structure.D = motorVal[2];
	}
}
task main()	{
	int maxS = 1;
  for(int i = 0; i<4; i++) {
		if (abs(motorVal[i]) > maxS){
			maxS = abs(motorVal[i]);
		}
	}
	for(int i = 0; i<4; i++) {
		motorVal[i] = motorVal[i] * (SPEED/maxS);
	}
	motorIn.structure.A = motorVal[3];
	motorIn.structure.B = motorVal[0];
	motorIn.structure.C = motorVal[1];
	motorIn.structure.D = motorVal[2];
	tHTIRS2 irSeeker1;
	tHTIRS2 irSeeker2;
	initSensor(&irSeeker1, IRfront);
	initSensor(&irSeeker2, IRback); //Initialising IR sensor's.
	initPFMotors();
	startMotorTask(); //Allows PF's to work
	for(int i = 0; i < 4; i++) {
		motorIn.array[i] = 0;
	} //Array for movement
	target = SensorValue[S3];
	while(true) {
		//writeDebugStream("ballDir is %d\n", ballDir);
		//writeDebugStream("ballDir is %d\n", ballDir);
		readSensor(&irSeeker1);
		readSensor(&irSeeker2); //Reading IR Sensors
		strength1 = irSeeker1.enhStrength;
		strength2 = irSeeker2.enhStrength;
		current = SensorValue[S3];
		correction = calculateCorrection(target, current); //Compass and Corrections
		if(ballDir < 10 && ballDir > 4) { //register which sensor in use via ballDir >>> figure IR strength >>> orbitDir[type] = orbitDir
			if(strength1 < 100) {
				orbitDir = orbitDirClose[ballDir];
			}
			if(strength1 > 100) {
				orbitDir = orbitDirFar[ballDir];
			}
		}
		else {
			if(strength2 < 100) {
				orbitDir = orbitDirClose[ballDir];
			}
			if(strength2 > 100) {
				orbitDir = orbitDirFar[ballDir];
			}
		}
		ballDir = calculateBallDir(irSeeker1.enhStrength, irSeeker2.enhStrength, irSeeker1.acDirection, irSeeker2.acDirection);
		writeDebugStream("Speed %4d %4d\n", ballDir, orbitDirFar[ballDir], orbitDirClose[ballDir]);
		moving(orbitDir, correction); //Actually moving the robot 0_0
		//			displayTextLine(1, "D:%4d %4d %3d", irSeeker1.dcDirection, irSeeker1.acDirection, irSeeker1.enhDirection);
		//			displayTextLine(2, "D:%4d %4d %3d", irSeeker2.dcDirection, irSeeker2.acDirection, irSeeker2.enhDirection);
		//			displayTextLine(1, "D: %4d %4d", irseeker1.acDirection);
		//			displayTextLine(3, "D:%4d %4d %3d", compassValue);
		//			displayTextLine(4, "D:%4d %4d %3d", current);
		//			displayTextLine(5, "D: %4d %4d %3d", correction;
		//			displayTextLine(5, "D: %4d %4d %3d", SensorValue[S3]);
	}
}

#pragma config(Sensor, S1,     irFront,        sensorI2CCustom)
#pragma config(Sensor, S2,     irBack,         sensorNone)
#pragma config(Sensor, S3,     compass,        sensorEV3_GenericI2C)
#pragma config(Sensor, S4,     UltraBa,        sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          frontleft,     tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorB,          frontright,    tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorC,          backright,     tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorD,          backleft,      tmotorEV3_Medium, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-irseeker-v2.h"
#include "PF_Motors.c"
#include "PF_Motors.c"
#define COMP_MULTI 0.05 //1:.075, 2:
int irFrontDir, irFrontStr, irBackDir, irBackStr;
tHTIRS2 irSeeker1;
tHTIRS2 irSeeker2;
int comp;
int motorSpeedA;
int motorSpeedB;
int motorSpeedC;
int motorSpeedD;
int defStr = 200;
int ultra;
int current;
int target;
int speed = 70;
int corspeed = 100 - speed;

float caluculateCorrection(int target, int current) { //Coverting values for compass correct
    float correction = (target - current) * 2;
    if(correction > 180) {
        correction -= 360;
    }
    else if(correction < -180) {
        correction += 360;
    }
    correction *= COMP_MULTI * -1;
    return correction;
}
bool compcorrection(){
	comp = caluculateCorrection(target, current); // Calculate the correction
	if (abs(comp) < 5 || abs(comp) > 175) {
		return true;
		} else if (comp > 0) {
		motorIn.structure.A = motorSpeedA - corspeed;
		motorIn.structure.B = motorSpeedB - corspeed;
		motorIn.structure.C = motorSpeedC + corspeed;
		motorIn.structure.D = motorSpeedD + corspeed;
		} else {
		motorIn.structure.A = motorSpeedA + corspeed;
		motorIn.structure.B = motorSpeedB + corspeed;
		motorIn.structure.C = motorSpeedC - corspeed;
		motorIn.structure.D = motorSpeedD - corspeed;
	}
	return false;
}


void still(){
	motorIn.structure.A=0;
	motorIn.structure.B=0;
	motorIn.structure.C=0;
	motorIn.structure.D=0;
}
void front(){
	motorIn.structure.A=-speed;
	motorIn.structure.B=-speed;
	motorIn.structure.C=-speed;
	motorIn.structure.D=-speed;
}

void back(){
	motorIn.structure.A=speed;
	motorIn.structure.B=speed;
	motorIn.structure.C=speed;
	motorIn.structure.D=speed;
}

void left(){
	motorIn.structure.A=-speed;
	motorIn.structure.B=speed;
	motorIn.structure.C=-speed;
	motorIn.structure.D=speed;
}

void right(){
	motorIn.structure.A=speed;
	motorIn.structure.B=-speed;
	motorIn.structure.C=speed;
	motorIn.structure.D=-speed;
}

void leftfront(){
	motorIn.structure.A=0;
	motorIn.structure.B=speed;
	motorIn.structure.C=0;
	motorIn.structure.D=speed;
}

void rightfront(){
	motorIn.structure.A=speed;
	motorIn.structure.B=0;
	motorIn.structure.C=speed;
	motorIn.structure.D=0;
}

void leftback(){
	motorIn.structure.A=-speed;
	motorIn.structure.B=0;
	motorIn.structure.C=-speed;
	motorIn.structure.D=0;
}
void rightback(){
	motorIn.structure.A=speed;
	motorIn.structure.B=0;
	motorIn.structure.C=speed;
	motorIn.structure.D=0;
}

void ultraCondition() {
	if(ultra >= 90) {
		motorIn.structure.A = motorSpeedA - 120;
		motorIn.structure.B = motorSpeedB - 120;
		motorIn.structure.C = motorSpeedC - 120;
		motorIn.structure.D = motorSpeedD - 120;
	}
}
task main {
	initPFMotors();
	startMotorTask();
	initSensor(&irSeeker1, irFront);
	initSensor(&irSeeker2, irBack);
	target = SensorValue[S3];
	while(true) {
		readSensor(&irSeeker1);
		readSensor(&irSeeker2);
		motorSpeedA = getMotorSpeed(motorA);
		motorSpeedB = getMotorSpeed(motorB);
		motorSpeedC = getMotorSpeed(motorC);
		motorSpeedD = getMotorSpeed(motorD);
		compcorrection();
		ultraCondition();
		current = SensorValue[S3];
		irFrontDir = irSeeker1.acDirection;
		irFrontStr = irSeeker1.enhStrength;
		irBackDir = irSeeker2.acDirection;
		irBackStr = irSeeker2.enhStrength;
		if(SensorValue(S2)<10){
			still();
		}
		ultra = SensorValue[S4];
		if(irFrontStr >= irBackStr) {
			switch(irFrontDir) {
			case 1:
				right();
				break;
			case 2:
				right();
				break;

			case 3:
				right();
				break;

			case 4:
				right();
				break;

			case 5:
				front();
				break;

			case 6:
				left();
				break;

			case 7:
				left();
				break;

			case 8:
				left();
				break;

			case 9:
				left();
				break;
			default:
				still();
				break;
			}
		}
		else
		{
			switch(irBackDir) {
			case 1:
				left();
				break;
			case 2:
				left();
				break;
			case 3:
				left();
				break;
			case 4:
				left();
				break;
			case 5:
				back();
				break;
			case 6:
				right();
				break;
			case 7:
				right();
				break;
			case 8:
				right();
				break;
			case 9:
				right();
				break;
			}
		}
	}
}

#pragma config(Sensor, S1,     irBack,         sensorI2CCustom)
#pragma config(Sensor, S2,     irFront,        sensorI2CCustom)
#pragma config(Sensor, S3,     compass,        sensorEV3_GenericI2C)
#pragma config(Motor,  motorA,          frontleft,     tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorB,          frontright,    tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorC,          backleft,      tmotorEV3_Medium, openLoop, reversed, encoder)
#pragma config(Motor,  motorD,          backright,     tmotorEV3_Medium, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//check movement for motors --> proceed to see why it is not running.
#include "hitechnic-irseeker-v2.h"
#include "PF_Motors.c"
#include "PF_Motors.h"

long irFrontDir, irFrontStr;
long irBackDir, irBackStr;

tHTIRS2 irSeeker1;
tHTIRS2 irSeeker2;

int comp;
int minus = SensorValue(S3);
int speed = 100;

bool compcorrection(){
	comp = SensorValue(S3) - minus;
	if(comp < 0){
		comp = 180 + comp;
	}
	if(comp < 5 || comp > 175){
		return true;
	}
	else if(comp > 90){
		motorIn.structure.A = -1*(comp-180);
		motorIn.structure.B= -(comp-180);
		motorIn.structure.C=(comp-180);
		motorIn.structure.D=(comp-180);
	}
	else{
		motorIn.structure.A=-comp;
		motorIn.structure.B=-comp;
		motorIn.structure.C=comp;
		motorIn.structure.D=comp;
	}
	return false;
}

void front(){
	motorIn.structure.A=speed;
	motorIn.structure.B=speed;
	motorIn.structure.C=speed;
	motorIn.structure.D=speed;
}

void back(){
	motorIn.structure.A=-speed;
	motorIn.structure.B=-speed;
	motorIn.structure.C=-speed;
	motorIn.structure.D=-speed;
}

void left(){
	motorIn.structure.A=-speed;
	motorIn.structure.B=speed;
	motorIn.structure.C=speed;
	motorIn.structure.D=-speed;
}

void right(){
	motorIn.structure.A=speed;
	motorIn.structure.B=-speed;
	motorIn.structure.C=-speed;
	motorIn.structure.D=speed;
}

void leftfront(){
	motorIn.structure.A=0;
	motorIn.structure.B=speed;
	motorIn.structure.C=speed;
	motorIn.structure.D=0;
}

void rightfront(){
	motorIn.structure.A=speed;
	motorIn.structure.B=0;
	motorIn.structure.C=0;
	motorIn.structure.D=speed;
}

void leftback(){
	motorIn.structure.A=-speed;
	motorIn.structure.B=0;
	motorIn.structure.C=0;
	motorIn.structure.D=-speed;
}
void still() {
	motorIn.structure.A=0;
	motorIn.structure.B=0;
	motorIn.structure.C=0;
	motorIn.structure.D=0;
}
void rightback(){
	motorIn.structure.A=0;
	motorIn.structure.B=-speed;
	motorIn.structure.C=-speed;
	motorIn.structure.D=0;
}

void goalie(){
	irFrontDir = irSeeker1.acDirection;
	irFrontStr = irSeeker1.enhStrength;
	irBackDir = irSeeker2.acDirection;
	irBackStr = irSeeker2.enhStrength;
	if(SensorValue(S2)<10){
		front();
	}
	else if(SensorValue(S1)>30){
		left();
	}
	else if(SensorValue(S1)<25){
		right();
	}
	else if(SensorValue(S2)>15){W
		back();
	}
	else if(irFrontStr < 20){
		motorIn.structure.A=0;
		motorIn.structure.B=0;
		motorIn.structure.C=0;
		motorIn.structure.D=0;
	}
	else{
		switch(irFrontDir){

		case 0:
			motorIn.structure.A=0;
			motorIn.structure.B=0;
			motorIn.structure.C=0;
			motorIn.structure.D=0;
			break;

		case 1:
			back();
			break;

		case 2:
			left();
			break;

		case 3:
			leftfront();
			break;

		case 4:
			leftfront();
			break;

		case 5:
			front();
			break;

		case 6:
			rightfront();
			break;

		case 7:
			rightfront();
			break;

		case 8:
			right();
			break;

		case 9:
			rightback();
			break;
		default:
			still();
			break;
		}
	}
}

task main{
	initPFMotors();
	startMotorTask();
	initSensor(&irSeeker1, irBack);
	initSensor(&irSeeker2, irFront);
	while(true){
		goalie();
		writeDebugStreamLine("goalie");
	}
}

#pragma config(Sensor, S1,     IRfront,        sensorI2CCustom)
#pragma config(Sensor, S2,     IRback,         sensorI2CCustom)
#pragma config(Sensor, S3,     Compass,        sensorEV3_GenericI2C)
#pragma config(Motor,  motorA,          brPF,          tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorB,          frPF,          tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorC,          flPF,          tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorD,          blPF,          tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-irseeker-v2.h" //IRsensor Library
#include "PF_Motors.h" // PF Motor Library
#include "PF_Motors.c" // PF Motor Library

#define DEG2RAD(angleDegrees) (angleDegrees * 3.141592 / 180.0)
#define RAD2DEG(angleRadians) (angleRadians * 180.0 / 3.141592)

#define COMP_MULTI 0.7 //Compass Multiplier (Sense of Direction in degrees)
#define SPEED 100 //Motor speed

int current; //Compass value at the start of program
int target; //Target
float motorVal[4] = {0, 0, 0, 0}; //Motor Functions

float ballDir; //Direction of ball
float pgmStart; //Timer Start
float compassValue; //Current compass value
float correction;
float frontStr; //Front IR sensor beacon strength detection variable
float backStr; //Back IR sensor beacon strength detection variable
float max(float a, float b) { //Defining 'Max' variable
	return a > b? a : b;
}

int maxS;
int orbitDir[18] = {
	0, //Front
	30, //
	75, //Front Right
	100, //
	145, //Right
	165, //Right
	210, //
	235, //Back Right
	255, //
	90, //Back
	105, //
	125, //Back Left
	150, //
	195, //Left
	215, //Left
	260, //
	285, //Front Left
	330 //
};

float calculateCorrection(int target, int current) {
	float error = current - target;
	if (error > 90) {
		error -= 180;
		} else if (error < -90) {
		error += 180;
	}
	return error * COMP_MULTI;
}

int calculateBallDir(int frontStr, int backStr, int frontDir, int backDir) {
	int ballDir;
	if(frontStr >= backStr){
		switch(frontDir) {
		case 1:
			ballDir = 14;
			break;
		case 2:
			ballDir = 15;
			break;
		case 3:
			ballDir = 16;
			break;
		case 4:
			ballDir = 17;
			break;
		case 5:
			ballDir = 0;
			break;
		case 6:
			ballDir = 1;
			break;
		case 7:
			ballDir = 2;
			break;
		case 8:
			ballDir = 3;
			break;
		case 9:
			ballDir = 4;
			break;
		default:
			ballDir = 4;
		}
		} else {
		switch(backDir) { // NOTE: Find out how to get AROUND the ball, not directly at it
		case 1:
			ballDir = 5;
			break;
		case 2:
			ballDir = 6;
			break;
		case 3:
			ballDir = 7;
			break;
		case 4:
			ballDir = 8;
			break;
		case 5:
			ballDir = 9;
			break;
		case 6:
			ballDir = 10;
			break;
		case 7:
			ballDir = 11;
			break;
		case 8:
			ballDir = 12;
			break;
		case 9:
			ballDir = 13;
			break;
		default:
			ballDir = 9;
		}
	}
	return ballDir;
}

void moving(int Dir, float correction) {
//	writeDebugStream("Speed %4d\n", correction);
	int angles[4] = {45, 135, 225, 315};
	for(int i = 0; i < 4; i++) {
		int moveDir = angles[i] + Dir;
		while(moveDir >= 360) {
			moveDir -= 360;
		}
		motorVal[i] = cosDegrees(angles[i] + Dir)*SPEED + correction*COMP_MULTI;
		//writeDebugStream("Speed %4d %4f\n", i, motorVal[i]);
	}
	maxS = 1;
	for(int i = 0; i<4; i++) {
		motorIn.structure.D = motorVal[2];
	}
}
task main()	{
	 if (maxS == 0) {
   maxS = 1;
  }
  for(int i = 0; i<4; i++) {
		if (abs(motorVal[i]) > maxS){
			maxS = abs(motorVal[i]);
		}
	}
	for(int i = 0; i<4; i++) {
		motorVal[i] = motorVal[i] * (SPEED/maxS);
	}
	motorIn.structure.A = motorVal[3];
	motorIn.structure.B = motorVal[0];
	motorIn.structure.C = motorVal[1]
	tHTIRS2 irSeeker1;
	tHTIRS2 irSeeker2;
	initSensor(&irSeeker1, IRfront);
	initSensor(&irSeeker2, IRback); //Initialising IR sensor's.
	initPFMotors();
	startMotorTask(); //Allows PF's to work
	for(int i = 0; i < 4; i++) {
		motorIn.array[i] = 0;
	} //Array for movement
	target = SensorValue[S3];
	while(true) {
		//writeDebugStream("ballDir is %d\n", ballDir);
		//writeDebugStream("ballDir is %d\n", ballDir);
		readSensor(&irSeeker1);
		readSensor(&irSeeker2); //Reading IR Sensors
		current = SensorValue[S3];
		correction = calculateCorrection(target, current); //Compass and Corrections
		ballDir = calculateBallDir(irSeeker1.enhStrength, irSeeker2.enhStrength, irSeeker1.acDirection, irSeeker2.acDirection);
		writeDebugStream("1 2 ballDir %4d %4d %4d\n", irSeeker1.enhStrength, irSeeker2.enhStrength, ballDir);
//		moving(orbitDir[ballDir], correction); //Actually moving the robot 0_0
		//			displayTextLine(1, "D:%4d %4d %3d", irSeeker1.dcDirection, irSeeker1.acDirection, irSeeker1.enhDirection);
		//			displayTextLine(2, "D:%4d %4d %3d", irSeeker2.dcDirection, irSeeker2.acDirection, irSeeker2.enhDirection);
		//			displayTextLine(1, "D: %4d %4d", irseeker1.acDirection);
		//			displayTextLine(3, "D:%4d %4d %3d", compassValue);
		//			displayTextLine(4, "D:%4d %4d %3d", current);
		//			displayTextLine(5, "D: %4d %4d %3d", correction;
		//			displayTextLine(5, "D: %4d %4d %3d", SensorValue[S3]);
	}
}

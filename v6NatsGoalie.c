#pragma config(Sensor, S1,     irFront,         sensorI2CCustom)
#pragma config(Sensor, S3,     compass,         sensorEV3_GenericI2C)
#pragma config(Sensor, S4,     UltraBa,         sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          frontleft,     tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorB,          frontright,    tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorC,          backright,     tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorD,          backleft,      tmotorEV3_Medium, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "hitechnic-irseeker-v2.h"
#include "PF_Motors.c"
int irFrontDir, irFrontStr;
tHTIRS2 irSeeker1;
int comp;
int defStr = 200;
unsigned long pgmStart;
unsigned long timerDuration = 2000; // Adjust the duration as needed
unsigned long timerStart = nPgmTime;
task TimerRestart() {
	while (true) {
		if (nPgmTime - timerStart >= timerDuration) {
			// Restart the timer when the duration is reached
			timerStart = nPgmTime;
		}
	}
}
int minus = SensorValue(S3);
int speed = 100;
bool compcorrection(){
	comp = SensorValue(S3) - minus;
	if(comp < 0){
		comp = 180 + comp;
	}
	if(comp < 5 || comp > 175){
		return true;
	}
	else if(comp > 90){
		motorIn.structure.A = -1*(comp-180);
		motorIn.structure.B = -(comp-180);
		motorIn.structure.C = (comp-180);
		motorIn.structure.D = (comp-180);
	}
	else{
		motorIn.structure.A = -comp;
		motorIn.structure.B = -comp;
		motorIn.structure.C = comp;
		motorIn.structure.D = comp;
	}
	return false;
}
void rightspot(){
	motorIn.structure.A = 0;
	motorIn.structure.B = -speed;
	motorIn.structure.C = speed;
	motorIn.structure.D = 0;
}
void leftspot(){
	motorIn.structure.A = 0;
	motorIn.structure.B = speed;
	motorIn.structure.C = -speed;
	motorIn.structure.D = 0;
}
void still(){
	motorIn.structure.A = 0;
	motorIn.structure.B = 0;
	motorIn.structure.C = 0;
	motorIn.structure.D = 0;
}
void front(){
	motorIn.structure.A = -speed;
	motorIn.structure.B = -speed;
	motorIn.structure.C = -speed;
	motorIn.structure.D = -speed;
}
void back(){
	motorIn.structure.A = speed;
	motorIn.structure.B = speed;
	motorIn.structure.C = speed;
	motorIn.structure.D = speed;
}
void left(){
	motorIn.structure.A = -speed;
	motorIn.structure.B = speed;
	motorIn.structure.C = -speed;
	motorIn.structure.D = speed;
}
void right(){
	motorIn.structure.A = speed;
	motorIn.structure.B = -speed;
	motorIn.structure.C = speed;
	motorIn.structure.D = -speed;
}
void leftfront(){
	motorIn.structure.A = 0;
	motorIn.structure.B = speed;
	motorIn.structure.C = 0;
	motorIn.structure.D = speed;
}
void rightfront(){
	motorIn.structure.A = speed;
	motorIn.structure.B = 0;
	motorIn.structure.C = speed;
	motorIn.structure.D = 0;
}
void leftback(){
	motorIn.structure.A = -speed;
	motorIn.structure.B = 0;
	motorIn.structure.C = -speed;
	motorIn.structure.D = 0;
}
void rightback(){
	motorIn.structure.A = speed;
	motorIn.structure.B = 0;
	motorIn.structure.C = speed;
	motorIn.structure.D = 0;
}
int movementStateFor = 0;
int movementStateRf = 0;
int movementStateLf = 0;
bool stopAndStart = false;
unsigned long stopStartTime = 0;
void frontcon(){
	if (stopAndStart) {
		if (nPgmTime - stopStartTime < 250) {
			// Move backward for 0.25 seconds
			back();
			} else {
			// Resume normal forward movement
			stopAndStart = false;
			pgmStart = nPgmTime;
			front();
		}
		} else if (irFrontStr >= defStr) {
		if (nPgmTime - pgmStart >= timerDuration) {
			pgmStart = nPgmTime;
			movementStateFor = 1;
			} else if (nPgmTime - pgmStart >= timerDuration / 2) {
			movementStateFor = 2;
		}
		} else {
		movementStateFor = 0;
	}

	// Motor control based on movementStateFor
	switch (movementStateFor) {
	case 1:
		front();
		break;
	case 2:
		back();
		break;
	default:
		still();
		break;
	}
}

void rfcon(){
	if (irFrontStr >= defStr) {
		if (nPgmTime - pgmStart >= timerDuration) {
			pgmStart = nPgmTime;
			movementStateRf = 1;
			} else if (nPgmTime - pgmStart >= timerDuration / 2) {
			movementStateRf = 2;
		}
		} else {
		movementStateRf = 0;
	}
	if (movementStateRf == 1) {
		rightfront();
		} else if (movementStateRf == 2) {
		leftback();
		} else {
		still();
	}
}
void lfcon(){
	if (irFrontStr >= defStr) {
		if (nPgmTime - pgmStart >= timerDuration) {
			pgmStart = nPgmTime;
			movementStateLf = 1;
			} else if (nPgmTime - pgmStart >= timerDuration / 2) {
			movementStateLf = 2;
		}
		} else {
		movementStateLf = 0;
	}
	if (movementStateLf == 1) {
		leftfront();
		} else if (movementStateLf == 2) {
		rightback();
		} else {
		still();
	}
}
task main {
	initPFMotors();
	startMotorTask();
	pgmStart = nPgmTime;
	initSensor(&irSeeker1, irFront);
	startTask(TimerRestart);
	while (true) {
		readSensor(&irSeeker1);
		int ir1 = SensorValue[S1];
		writeDebugStream("irvalue %4d/n", ir1);
		irFrontDir = irSeeker1.acDirection;
		irFrontStr = irSeeker1.enhStrength;
		if (SensorValue(S2) < 10) {
			still();
		}
		switch(irFrontDir) {
		case 1:
			left();
			break;
		case 2:
			left();
			break;
		case 3:
			left();
			break;
		case 4:
			frontcon();
			break;
		case 5:
			frontcon();
			break;
		case 6:
			frontcon();
			break;
		case 7:
			right();
			break;
		case 8:
			right();
			break;
		case 9:
			right();
			break;
		default:
			still();
			break;
		}
		// Check for the UltraBa condition to stop and start
		if (SensorValue[UltraBa] >= 72 && !stopAndStart) {
			stopAndStart = true;
			stopStartTime = nPgmTime;
			still(); // Stop the robot
		}
	}
}

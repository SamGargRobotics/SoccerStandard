#pragma config(Sensor, S2,     irFront,         sensorI2CCustom)
#pragma config(Sensor, S1,     irBack,        sensorI2CCustom)
#pragma config(Sensor, S3,     compass,        sensorEV3_GenericI2C)
#pragma config(Motor,  motorA,          frontleft,     tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorB,          frontright,    tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorC,          backright,      tmotorEV3_Medium, openLoop, reversed, encoder)
#pragma config(Motor,  motorD,          backleft,     tmotorEV3_Medium, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-irseeker-v2.h"
#include "PF_Motors.c"

int irFrontDir, irFrontStr;
int irBackDir, irBackStr;

tHTIRS2 irSeeker1;
tHTIRS2 irSeeker2;

int comp;
unsigned long pgmStart;
unsigned long timerDuration = 2000; // Adjust the duration as needed
unsigned long timerStart = nPgmTime;

task TimerRestart() {
	while (true) {
		if (nPgmTime - timerStart >= timerDuration) {
			// Restart the timer when the duration is reached
			timerStart = nPgmTime;
		}
	}
}

int minus = SensorValue(S3);
int speed = 100;

bool compcorrection(){
	comp = SensorValue(S3) - minus;
	if(comp < 0){
		comp = 180 + comp;
	}
	if(comp < 5 || comp > 175){
		return true;
	}
	else if(comp > 90){
		motorIn.structure.A = -1*(comp-180);
		motorIn.structure.B= -(comp-180);
		motorIn.structure.C=(comp-180);
		motorIn.structure.D=(comp-180);
	}
	else{
		motorIn.structure.A=-comp;
		motorIn.structure.B=-comp;
		motorIn.structure.C=comp;
		motorIn.structure.D=comp;
	}
	return false;
}

void rightspot(){
	motorIn.structure.A=0;
	motorIn.structure.B=-speed;
	motorIn.structure.C=speed;
	motorIn.structure.D=0;
}

void leftspot(){
	motorIn.structure.A=0;
	motorIn.structure.B=speed;
	motorIn.structure.C=-speed;
	motorIn.structure.D=0;
}

void still(){
	motorIn.structure.A=0;
	motorIn.structure.B=0;
	motorIn.structure.C=0;
	motorIn.structure.D=0;
}
void front(){
	motorIn.structure.A=speed;
	motorIn.structure.B=speed;
	motorIn.structure.C=speed;
	motorIn.structure.D=speed;
}

void back(){
	motorIn.structure.A=-speed;
	motorIn.structure.B=-speed;
	motorIn.structure.C=-speed;
	motorIn.structure.D=-speed;
}

void left(){
	motorIn.structure.A=-speed;
	motorIn.structure.B=speed;
	motorIn.structure.C=-speed;
	motorIn.structure.D=speed;
}

void right(){
	motorIn.structure.A=speed;
	motorIn.structure.B=-speed;
	motorIn.structure.C=speed;
	motorIn.structure.D=-speed;
}

void leftfront(){
	motorIn.structure.A=0;
	motorIn.structure.B=speed;
	motorIn.structure.C=0;
	motorIn.structure.D=speed;
}

void rightfront(){
	motorIn.structure.A=speed;
	motorIn.structure.B=0;
	motorIn.structure.C=speed;
	motorIn.structure.D=0;
}

void leftback(){
	motorIn.structure.A=-speed;
	motorIn.structure.B=0;
	motorIn.structure.C=-speed;
	motorIn.structure.D=0;
}
void rightback(){
	motorIn.structure.A=speed;
	motorIn.structure.B=0;
	motorIn.structure.C=speed;
	motorIn.structure.D=0;
}

int movementState = 0; // 0: Stop, 1: Move forward, 2: Move backward

void frontcon(){
	if (irFrontStr >= 40) {
		if (nPgmTime - pgmStart >= timerDuration) {
			pgmStart = nPgmTime;
			movementState = 1; // Start moving forward when the condition is met
			} else if (nPgmTime - pgmStart >= timerDuration / 2) {
			movementState = 2; // Reverse after half of the timer duration
		}
		} else {
		movementState = 0; // Stop if the condition is not met
	}

	// Control motor movements based on the movementState
	if (movementState == 1) {
		front(); // Move forward
		} else if (movementState == 2) {
		back(); // Move backward
		} else {
		still(); // Stop
	}
}


task main {
	initPFMotors();
	startMotorTask();
	pgmStart = nPgmTime;
	initSensor(&irSeeker1, irBack);
	initSensor(&irSeeker2, irFront);
	startTask(TimerRestart);
	while(true){
		readSensor(&irSeeker1);
		readSensor(&irSeeker2);
		int ir1 = SensorValue[S1];
		writeDebugStream("irvalue %4d/n", ir1);
		irFrontDir = irSeeker1.acDirection;
		irFrontStr = irSeeker1.enhStrength;
		irBackDir = irSeeker2.acDirection;
		irBackStr = irSeeker2.enhStrength;
		if(SensorValue(S2)<10){
			still();
		}
		if(irFrontStr >= irBackStr) {
			switch(irFrontDir) {
			case 1:
				leftspot();
				break;
			case 2:
				leftspot();
				break;

			case 3:
				leftspot();
				break;

			case 4:
				frontcon();
				break;

			case 5:
				frontcon();
				break;

			case 6:
				frontcon();
				break;

			case 7:
				rightspot();
				break;

			case 8:
				rightspot();
				break;

			case 9:
				rightspot();
				break;
			default:
				still();
				break;
			}
		}
		else
		{
			switch(irBackDir) {
			case 1:
				rightspot();
				break;
			case 2:
				rightspot();
				break;
			case 3:
				rightspot();
				break;
			case 4:
				rightspot();
				break;
			case 5:
				still();
				break;
			case 6:
				still();
				break;
			case 7:
				leftspot();
				break;
			case 8:
				leftspot();
				break;
			case 9:
				leftspot();
				break;
			}
		}
	}
}
